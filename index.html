<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>นกบิน ออนไลน์</title>
  <style>
    :root{ --bg1:#e0f2ff;--bg2:#fef5ff;--ink:#0f172a;--muted:#64748b;--accent:#22c55e;--boss:#8b5cf6;--coin:#facc15;--fire:#fb923c; --card:#ffffff;--border:#e5e7eb; --ham:#a16207; --ham-ear:#854d0e; --ham-belly:#fef3c7; --block:#60a5fa; --beam:#06b6d4; --shard:#0ea5e9; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{ margin:0; display:grid; place-items:center; padding:16px; background:linear-gradient(180deg,var(--bg1),var(--bg2)); font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; color:var(--ink); }
    .card{ width:min(560px,100%); background:var(--card); border:1px solid var(--border); border-radius:18px; box-shadow:0 10px 30px rgba(2,6,23,.06); padding:16px; }
    .row{display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px; flex-wrap:wrap}
    .muted{color:var(--muted); font-size:12px}
    button{ border:0; background:#f1f5f9; padding:8px 12px; border-radius:12px; cursor:pointer; transition:transform .1s ease, box-shadow .2s ease; font-size:13px; }
    button:hover{ box-shadow:0 6px 16px rgba(2,6,23,.08)}
    button:active{ transform:scale(.97)}
    #playBtn{ background:var(--accent); color:white }
    canvas{ width:100%; height:auto; image-rendering:auto; display:block; border-radius:14px; border:1px solid var(--border) }
    .namebox{ display:flex; align-items:center; gap:6px; background:#f8fafc; border:1px solid #e2e8f0; padding:6px 8px; border-radius:10px }
    .namebox input{ border:0; outline:none; background:transparent; min-width:140px; font-size:13px }
    .tag{display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; background:#eef2ff; color:#4338ca}
  </style>
</head>
<body>
  <main class="card">
    <div class="row">
      <div>
        <strong>นกบิน ออนไลน์</strong>
        <div class="muted">พิมพ์ชื่อก่อนเล่น • แตะ/คลิก/Space กระโดด</div>
        <div class="muted" style="margin-top:6px">
          <span class="tag">บอสสุ่ม: test1 / test2 / test3</span>
          <span class="tag">บอส: สุ่มเหรียญต้องเก็บ 3–50</span>
          <span class="tag">ฆ่าบอสแล้วฉากเร็วขึ้น</span>
          <span class="tag">แฮมสเตอร์: x10 คะแนน 5 วิ (20%)</span>
        </div>
      </div>
      <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-end">
        <div class="namebox">
          <span class="muted">ชื่อ</span>
          <input id="playerName" type="text" maxlength="16" placeholder="พิมพ์ชื่อก่อนเล่น" />
        </div>
        <button id="playBtn">เริ่มใหม่</button>
      </div>
    </div>

    <canvas id="game" width="480" height="640" aria-label="Flappy Game"></canvas>

    <p class="muted" style="margin:10px 4px 2px">
      * สามารถใส่ไฟล์ <b>player.png</b> / <b>boss.png</b> ในโฟลเดอร์เดียวกับหน้านี้เพื่อใช้รูปฝั่งเรา • ถ้าไม่มีจะใช้ทรงพื้นฐาน<br>
      * จบเกมมีปุ่ม <b>ส่งสกอร์ออนไลน์</b> และ <b>เริ่มใหม่</b> • สกอร์บอร์ดอ่านจาก GitHub Issues
    </p>
  </main>

  <script>
  // ===== Utils (function declarations → hoist) =====
  function randRange(min,max){ return min + Math.random()*(max-min); }
  function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

  // ===== ค่าพื้นฐานเกม =====
  const WIDTH=480, HEIGHT=640;
  const PIPE_GAP=220, PIPE_INTERVAL=1.8, PIPE_SPEED=85, SPEED_RAMP_PER_MIN=0.25;
  const GRAVITY=900, JUMP_VELOCITY=-300, TERM_VY=420, START_EASE_SEC=2.0;
  const COIN_INTERVAL=0.9, COIN_SPEED=120;
  const BOSS_MIN_STEP=20, BOSS_MAX_STEP=30, BOSS_TOP=120, BOSS_BOTTOM=HEIGHT-160;

  // โจมตีบอส
  const FIRE_INTERVAL=1.2, FIRE_SPEED=160;                        // test1
  const BLOCK_INTERVAL=2.0, BLOCK_SPEED=140, BOSS_BLOCK_GAP=180;  // test2 (ท่อกั้น)
  const BEAM_INTERVAL=1.8, BEAM_SPEED=200, BEAM_SPLIT_DIST=110,   // test3 (ลำแสงแตกตัว)
        SHARD_COUNT=5, SHARD_SPEED=180;

  // เหรียญปราบบอส (สุ่ม 3–50)
  const MIN_COINS_TO_WIN=3, MAX_COINS_TO_WIN=50;

  // เพิ่มความเร็วฉากเมื่อชนะบอส
  const BOSS_SPEED_STEP = 0.08; // +8% ต่อบอส 1 ตัว

  // แฮมสเตอร์ (power-up)
  const HAMSTER_CHANCE = 0.20;
  const HAMSTER_MIN_GAP = 6;
  const HAMSTER_MAX_GAP = 10;
  const HAMSTER_SPEED_BONUS = 60;

  let pipeHide=0, PIPE_ANIM_SPEED=1.6;

  const cvs=document.getElementById('game');
  const ctx=cvs.getContext('2d');

  let pipes=[], t=0, spawnTimer=0, score=0, best=0;
  let playing=false, gameOver=false, deathRecorded=false, mode='normal';

  let bossKills=0, speedBossMul=1;
  let bossDefeatedThisRound=false;

  let lastBossScore=0, nextBossAt=randStep(lastBossScore,BOSS_MIN_STEP,BOSS_MAX_STEP);

  // แจ้งเตือนเล็ก (บน)
  let notiText='', notiTimer=0;

  // easing
  const easeOutCubic=x=>1-Math.pow(1-x,3);
  const easeInOutCubic=x=>x<.5?4*x*x*x:1-Math.pow(-2*x+2,3)/2;

  // ปุ่มจอ Game Over
  let gameOverButtons={ send:null, restart:null };

  // ===== ชื่อผู้เล่น =====
  const NAME_KEY='flappy_name_v1';
  const nameInput=document.getElementById('playerName');
  nameInput.value=localStorage.getItem(NAME_KEY)||'';
  nameInput.addEventListener('input',()=>localStorage.setItem(NAME_KEY,(nameInput.value||'').trim()));
  function ensureName(){ const n=(nameInput.value||'').trim(); if(!n){ notiText='พิมพ์ชื่อก่อนเริ่มเล่นนะ'; notiTimer=1.5; nameInput.focus(); return false;} return true; }

  // ===== ตัวละคร/บอส =====
  const player={x:WIDTH*0.28,y:HEIGHT*0.42,vy:0,w:36,h:36,img:null};
  const defaultImg=new Image(); defaultImg.src='player.png';
  defaultImg.onload=()=>player.img=defaultImg;
  defaultImg.onerror=()=>player.img=null;

  let boss=null, bossImg=null, coins=[], fires=[], coinTimer=0, fireTimer=0;

  const defaultBoss=new Image(); defaultBoss.src='boss.png';
  defaultBoss.onload=()=>bossImg=defaultBoss;
  defaultBoss.onerror=()=>bossImg=null;

  // test2 / test3 โครงสร้าง
  let bossBlocks=[], blockTimer=0;
  let beams=[], beamTimer=0, shards=[];

  // แฮมสเตอร์
  let hamster=null;
  let hamTimer=0, hamNextGap=randRange(HAMSTER_MIN_GAP, HAMSTER_MAX_GAP);
  let scoreMul=1, scoreMulTimer=0;
  let powerTextTimer=0; const POWER_TEXT_LIFETIME=1.8;

  document.getElementById('playBtn').addEventListener('click',()=>{ if(ensureName()) resetGame(); });

  window.addEventListener('keydown',e=>{
    if(e.code==='Space'){
      e.preventDefault();
      if(!playing){ if(ensureName()) resetGame(); }
      else if(!gameOver){ jump(); }
    }
  });

  cvs.addEventListener('pointerdown',(e)=>{
    const rect=cvs.getBoundingClientRect();
    const mx=(e.clientX-rect.left)*(cvs.width/rect.width);
    const my=(e.clientY-rect.top)*(cvs.height/rect.height);
    if(!playing){ if(ensureName()) resetGame(); return; }
    if(gameOver){
      if(hitButton(gameOverButtons.send,mx,my)) { openIssue(); return; }
      if(hitButton(gameOverButtons.restart,mx,my)) { resetGame(); return; }
      return;
    }
    jump();
  });

  function hitButton(btn,x,y){ if(!btn) return false; return (x>btn.x && x<btn.x+btn.w && y>btn.y && y<btn.y+btn.h); }

  function resetGame(){
    pipes=[]; coins=[]; fires=[]; boss=null; hamster=null;
    bossBlocks=[]; beams=[]; shards=[];
    deathRecorded=false;
    t=0; spawnTimer=0; coinTimer=0; fireTimer=0; blockTimer=0; beamTimer=0;
    hamTimer=0; hamNextGap=randRange(HAMSTER_MIN_GAP, HAMSTER_MAX_GAP);
    score=0; gameOver=false; playing=true;
    player.y=HEIGHT*0.42; player.vy=0; mode='normal'; pipeHide=0;

    bossKills=0; speedBossMul=1; bossDefeatedThisRound=false;

    powerTextTimer=0; scoreMul=1; scoreMulTimer=0;

    lastBossScore=0; nextBossAt=randStep(lastBossScore,BOSS_MIN_STEP,BOSS_MAX_STEP);
  }
  function jump(){ player.vy=player.vy*0.2 + JUMP_VELOCITY*0.8; }

  // ===== GitHub Issues =====
  const REPO_OWNER='sorawit222', REPO_NAME='flappy1';
  const GH_ISSUES_API=`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/issues?state=all&per_page=100`;
  const ISSUE_MARK='<!-- FLAPPY_SCORE_V1 -->';
  const REPO_ISSUE_NEW=`https://github.com/${REPO_OWNER}/${REPO_NAME}/issues/new`;

  let onlineScores=null, onlineFetchInFlight=false, onlineLastFetch=0;

  function parseScoreFromIssueBody(body){
    if((body||'').indexOf(ISSUE_MARK)===-1) return null;
    const m=body.match(/```json\s*([\s\S]*?)\s*```/i);
    if(!m) return null;
    try{
      const obj=JSON.parse(m[1]);
      return { name:String(obj.name||'ผู้เล่น'), score:Number(obj.score||0), speed:Number(obj.speed||1), ts:Number(obj.ts||Date.now()) };
    }catch{ return null; }
  }

  async function fetchScoresFromIssues(){
    try{
      const res=await fetch(GH_ISSUES_API,{headers:{'Accept':'application/vnd.github+json'}});
      if(!res.ok) return [];
      const issues=await res.json();
      const out=[];
      for(const it of issues){
        const s=parseScoreFromIssueBody(it?.body||'');
        if(s){ if(!Number.isFinite(s.ts) && it?.created_at) s.ts=Date.parse(it.created_at); out.push(s); }
      }
      out.sort((a,b)=> b.score - a.score || a.ts - b.ts);
      return out.slice(0,20);
    }catch{ return []; }
  }

  function ensureOnlineScores(){
    const now=Date.now();
    if(onlineFetchInFlight) return;
    if(onlineScores && (now-onlineLastFetch<10000)) return; // cache 10s
    onlineFetchInFlight=true;
    fetchScoresFromIssues().then(arr=>{ onlineScores=arr; onlineLastFetch=Date.now(); })
                           .finally(()=>{ onlineFetchInFlight=false; });
  }

  function openIssue(){
    const n=(nameInput.value||'').trim()||'ผู้เล่น';
    const speed = Number((speedBossMul).toFixed(2));
    const data={name:n, score, speed, ts:Date.now()};
    const title=encodeURIComponent(`นกบิน ออนไลน์: ${n} - ${score}`);
    const body=encodeURIComponent(`${ISSUE_MARK}\nส่งจากเกม\n\n\`\`\`json\n${JSON.stringify(data)}\n\`\`\``);
    const url=`https://github.com/${REPO_OWNER}/${REPO_NAME}/issues/new?title=${title}&body=${body}`;
    window.open(url,'_blank');
  }

  // ===== main loop =====
  let last=performance.now(); requestAnimationFrame(loop);
  function loop(now){ const dtRaw=(now-last)/1000; last=now; const dt=Math.min(dtRaw,1/30); update(dt); draw(); requestAnimationFrame(loop); }

  async function update(dt){
    if(notiTimer>0){ notiTimer-=dt; }
    if(powerTextTimer>0){ powerTextTimer-=dt; }

    // บัฟ x10: ลดเวลา + ตัดให้ชนศูนย์เสมอ
    if (scoreMulTimer > 0) {
      scoreMulTimer -= dt;
      if (scoreMulTimer <= 0) { scoreMul = 1; scoreMulTimer = 0; }
    }

    if(!playing||gameOver) return;

    t+=dt;
    const easeMul=t<START_EASE_SEC?(0.25+0.75*easeOutCubic(t/START_EASE_SEC)):1;
    const rampMul=1+(SPEED_RAMP_PER_MIN*(t/60));
    const scroll=PIPE_SPEED * easeMul * rampMul * speedBossMul;

    // ===== แฮมสเตอร์ spawn/check =====
    hamTimer += dt;
    if(!hamster && hamTimer >= hamNextGap){
      hamTimer = 0; hamNextGap = randRange(HAMSTER_MIN_GAP, HAMSTER_MAX_GAP);
      if(Math.random() < HAMSTER_CHANCE){
        const y = randInt(70, HEIGHT-140);
        hamster = { x: WIDTH+30, y, w:34, h:28, vx: scroll + HAMSTER_SPEED_BONUS, wob: Math.random()*Math.PI*2 };
      }
    }
    if(hamster){
      hamster.x -= hamster.vx*dt;
      hamster.wob += dt*4;
      hamster.y += Math.sin(hamster.wob)*10*dt;
      if(hamster.x < -40) hamster = null;
      const hit = aabbIntersect(player.x+6,player.y+6,player.w-12,player.h-12, hamster.x,hamster.y,hamster.w,hamster.h);
      if(hit){
        hamster = null;
        scoreMul = 10;
        scoreMulTimer = 5.0;
        powerTextTimer = POWER_TEXT_LIFETIME;
      }
    }

    if(mode==='normal'){
      spawnTimer+=dt;
      if(spawnTimer>=PIPE_INTERVAL){
        spawnTimer=0;
        const minTop=60,minBottom=80;
        const topH=Math.random()*(HEIGHT-PIPE_GAP-minTop-minBottom)+minTop;
        pipes.push({x:WIDTH+40,topH,passed:false});
      }
      for(const p of pipes){ p.x-=scroll*dt; }
      pipes=pipes.filter(p=>p.x>-80);

      for(const p of pipes){
        if(!p.passed && p.x+60<player.x){ p.passed=true; score += scoreMul; }
        if(collidePipe(p)){ gameOver=true; }
      }
      if(score-lastBossScore>=BOSS_MIN_STEP){
        if(score>=nextBossAt){ enterBoss(); }
        else {
          const pr=(score-lastBossScore-(BOSS_MIN_STEP-1))/(BOSS_MAX_STEP-BOSS_MIN_STEP+1);
          if(Math.random()<clamp(pr,0.05,0.6)) enterBoss();
        }
      }

    } else if(mode==='enterBoss'){
      pipeHide=clamp(pipeHide+PIPE_ANIM_SPEED*dt,0,1);
      if(pipeHide>=1){ mode='boss'; createBoss(); }

    } else if(mode==='boss'){
      if(boss){
        // เคลื่อนและลดเวลา "เจ็บ"
        boss.alpha=clamp(boss.alpha+dt*2,0,1);
        boss.scale=0.7+0.3*easeOutCubic(boss.alpha);
        boss.y+=boss.vy*boss.dir*dt;
        if(boss.y<BOSS_TOP){ boss.y=BOSS_TOP; boss.dir=1; }
        if(boss.y>BOSS_BOTTOM){ boss.y=BOSS_BOTTOM; boss.dir=-1; }
        if(boss.hurtTimer>0) boss.hurtTimer-=dt;
      }

      // เหรียญ
      coinTimer+=dt;
      if(coinTimer>=COIN_INTERVAL){
        coinTimer=0;
        const yy=boss?(boss.y+(Math.random()*60-30)):HEIGHT*0.4;
        coins.push({x:WIDTH+20,y:clamp(yy,60,HEIGHT-100),r:10,vx:COIN_SPEED,spin:Math.random()*Math.PI*2});
      }
      for(const c of coins){ c.x-=c.vx*dt; c.spin+=dt*6; } coins=coins.filter(c=>c.x>-30);

      // โจมตีตามชนิดบอส
      if(boss?.type==='test1'){ // ลูกไฟ
        fireTimer+=dt;
        if(fireTimer>=FIRE_INTERVAL){ fireTimer=0; fires.push({x:boss.x-28,y:boss.y,r:8,vx:FIRE_SPEED,phase:Math.random()*Math.PI*2}); }
        for(const f of fires){ f.x-=f.vx*dt; f.y+=Math.sin(f.phase+=dt*4)*12*dt; }
        fires=fires.filter(f=>f.x>-20);
        for(const f of fires){ if(rectCircleCollide(player.x+6,player.y+6,player.w-12,player.h-12,f.x,f.y,f.r)){ gameOver=true; break; } }

      } else if(boss?.type==='test2'){ // ท่อกั้น
        blockTimer+=dt;
        if(blockTimer>=BLOCK_INTERVAL){
          blockTimer=0;
          const minTop=50, minBottom=70, gap=BOSS_BLOCK_GAP;
          const topH=Math.random()*(HEIGHT-gap-minTop-minBottom)+minTop;
          bossBlocks.push({x:WIDTH+40, topH, gap, w:60});
        }
        for(const b of bossBlocks){ b.x -= (scroll+40)*dt; }
        bossBlocks=bossBlocks.filter(b=>b.x>-80);
        for(const b of bossBlocks){ if(collideBossBlock(b)){ gameOver=true; break; } }

      } else if(boss?.type==='test3'){ // ลำแสง + แตกตัว
        beamTimer+=dt;
        if(beamTimer>=BEAM_INTERVAL){
          beamTimer=0;
          beams.push({x:boss.x-8, y:boss.y, len:40, h:6, vx:BEAM_SPEED, splitX: player.x+BEAM_SPLIT_DIST, split:false});
        }
        for(const b of beams){
          b.x -= b.vx*dt;
          if(!b.split && b.x <= b.splitX){
            b.split = true;
            for(let i=0;i<SHARD_COUNT;i++){
              const angle = (-0.6 + i*(1.2/(SHARD_COUNT-1)));
              const sv = SHARD_SPEED*(1+Math.random()*0.2);
              shards.push({x:b.x-b.len, y:b.y, vx:sv, vy:sv*Math.sin(angle), r:4});
            }
          }
        }
        beams = beams.filter(b=>!b.split && b.x > -20);
        for(const s of shards){ s.x -= s.vx*dt; s.y += s.vy*dt; }
        shards = shards.filter(s=> s.x>-20 && s.y>-20 && s.y<HEIGHT);
        for(const b of beams){
          if(rectRectCollide(player.x+6,player.y+6,player.w-12,player.h-12, b.x-b.len, b.y-b.h/2, b.len, b.h)){ gameOver=true; break; }
        }
        for(const s of shards){
          if(rectCircleCollide(player.x+6,player.y+6,player.w-12,player.h-12, s.x, s.y, s.r)){ gameOver=true; break; }
        }
      }

      // ชนะบอสด้วยเหรียญ + ให้ feedback เจ็บ
      for(let i=coins.length-1;i>=0;i--){
        const c=coins[i];
        if(rectCircleCollide(player.x+6,player.y+6,player.w-12,player.h-12,c.x,c.y,c.r)){
          coins.splice(i,1);
          if(boss){
            boss.hits++;
            boss.hurtTimer = 0.18; // ระยะเวลาสั่น/แฟลช
            if(boss.hits>=boss.coinsToWin){
              fires=[]; bossBlocks=[]; beams=[]; shards=[];
              boss=null; mode='exitBoss'; bossDefeatedThisRound=true;
            }
          }
        }
      }

    } else if(mode==='exitBoss'){
      pipeHide=clamp(pipeHide-PIPE_ANIM_SPEED*dt,0,1);
      if(pipeHide<=0){ finishBoss(); mode='normal'; }
    }

    // ฟิสิกส์ผู้เล่น
    player.vy+=GRAVITY*dt; if(player.vy>TERM_VY) player.vy=TERM_VY;
    player.y+=player.vy*dt;
    if(player.y<0){ player.y=0; player.vy=0; }
    if(player.y+player.h>HEIGHT-30){ player.y=HEIGHT-30-player.h; gameOver=true; }

    if(gameOver && !deathRecorded){ deathRecorded=true; recordScoreLocal(); }
    if(gameOver){ best=Math.max(best,score); }
  }

  function enterBoss(){ mode='enterBoss'; }
  function createBoss(){
    const types=['test1','test2','test3'];
    const pick = types[Math.floor(Math.random()*types.length)];
    boss={
      type: pick,
      x:WIDTH*0.75, y:HEIGHT*0.32, vy:90, dir:1,
      hits:0, coinsToWin: randInt(MIN_COINS_TO_WIN, MAX_COINS_TO_WIN),
      alpha:0, scale:0.7, img:bossImg,
      hurtTimer:0
    };
    fires=[]; bossBlocks=[]; beams=[]; shards=[]; fireTimer=0; blockTimer=0; beamTimer=0;
    notiText = `พบ BOSS: ${pick}`; notiTimer = 1.8;
  }
  function finishBoss(){
    coins=[]; fires=[]; bossBlocks=[]; beams=[]; shards=[];
    if(bossDefeatedThisRound){
      bossKills++;
      speedBossMul = 1 + bossKills * BOSS_SPEED_STEP;
      bossDefeatedThisRound=false;
    }
    lastBossScore=score; nextBossAt=randStep(lastBossScore,BOSS_MIN_STEP,BOSS_MAX_STEP);
  }

  // ===== local score =====
  const SCORE_KEY='flappy_scores_v1', LAST_RUN_KEY='flappy_last_run_v1';
  function getLocalScores(){ try{return JSON.parse(localStorage.getItem(SCORE_KEY)||'[]');}catch{return [];} }
  function setLocalScores(a){ localStorage.setItem(SCORE_KEY,JSON.stringify(a)); }
  function recordScoreLocal(){
    const n=(nameInput.value||'').trim()||'ผู้เล่น';
    const run={ id:Date.now()+"_"+Math.random().toString(36).slice(2,7), name:n, score, speed:Number(speedBossMul.toFixed(2)), ts:Date.now()};
    let arr=getLocalScores(); arr.push(run);
    arr.sort((a,b)=> b.score-a.score || a.ts-b.ts); arr=arr.slice(0,10);
    setLocalScores(arr); localStorage.setItem(LAST_RUN_KEY,run.id);
    best=Math.max(best,...arr.map(r=>r.score));
  }

  // ===== collision / draw helpers =====
  function collidePipe(p){
    if(mode!=='normal'||pipeHide>0) return false;
    const pipeW=60; const gapY=p.topH; const gapB=p.topH+PIPE_GAP;
    const px=player.x+6, py=player.y+6, pw=player.w-12, ph=player.h-12;
    const hitX=(px<p.x+pipeW)&&(px+pw>p.x);
    if(!hitX) return false;
    if(py<gapY || (py+ph)>gapB) return true;
    return false;
  }
  function collideBossBlock(b){
    const pipeW=b.w||60, gapY=b.topH, gapB=b.topH+(b.gap||BOSS_BLOCK_GAP);
    const px=player.x+6, py=player.y+6, pw=player.w-12, ph=player.h-12;
    const hitX=(px<b.x+pipeW)&&(px+pw>b.x);
    if(!hitX) return false;
    if(py<gapY || (py+ph)>gapB) return true;
    return false;
  }
  function rectCircleCollide(rx,ry,rw,rh,cx,cy,cr){
    const cxst=clamp(cx,rx,rx+rw), cys=clamp(cy,ry,ry+rh);
    const dx=cx-cxst, dy=cy-cys; return (dx*dx+dy*dy)<=cr*cr;
  }
  function rectRectCollide(ax,ay,aw,ah, bx,by,bw,bh){
    return ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by;
  }
  function aabbIntersect(ax,ay,aw,ah, bx,by,bw,bh){
    return ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by;
  }
  function randStep(base,minStep,maxStep){ return base + Math.floor(minStep + Math.random()*(maxStep-minStep+1)); }

  function draw(){
    // BG
    ctx.clearRect(0,0,WIDTH,HEIGHT);
    const g=ctx.createLinearGradient(0,0,0,HEIGHT); g.addColorStop(0,'#c7f1ff'); g.addColorStop(1,'#ffe9ff');
    ctx.fillStyle=g; ctx.fillRect(0,0,WIDTH,HEIGHT);
    ctx.fillStyle='#d1fae5'; ctx.fillRect(0,HEIGHT-30,WIDTH,30);

    // pipes (ปกติ)
    const topOff=-pipeHide*HEIGHT, botOff=pipeHide*HEIGHT, alpha=1-easeInOutCubic(pipeHide);
    if(mode!=='boss'){ ctx.save(); ctx.globalAlpha=clamp(alpha,0,1); for(const p of pipes){ drawPipe(p,topOff,botOff);} ctx.restore(); }

    // player
    if(player.img){ ctx.drawImage(player.img,player.x,player.y,player.w,player.h); }
    else { ctx.fillStyle='#22c55e'; ctx.beginPath(); ctx.arc(player.x+player.w/2,player.y+player.h/2,player.w/2,0,Math.PI*2); ctx.fill(); }

    // boss mode
    if(mode==='boss'||mode==='exitBoss'){
      // วาดบอส (มีสั่น + แฟลชเมื่อโดน)
      if(boss){
        let shakeX=0, shakeY=0, flash=0;
        if(boss.hurtTimer>0){
          const k = clamp(boss.hurtTimer/0.18, 0, 1);
          shakeX = (Math.random()*2-1)*4*k;
          shakeY = (Math.random()*2-1)*3*k;
          flash  = k;
        }
        ctx.save();
        ctx.globalAlpha=clamp(boss.alpha,0,1);
        ctx.translate(boss.x+shakeX,boss.y+shakeY);
        ctx.scale(boss.scale,boss.scale);
        const s=56;
        if(bossImg){ ctx.drawImage(bossImg,-s/2,-s/2,s,s); }
        else { ctx.fillStyle='var(--boss)'; roundRect(ctx,-24,-24,48,48,12); ctx.fill(); }
        if(flash>0){
          ctx.globalAlpha = 0.35*flash;
          ctx.fillStyle = '#ef4444'; // แฟลชแดงเบา ๆ
          ctx.fillRect(-s/2,-s/2,s,s);
        }
        ctx.restore();
      }

      // โจมตี/สิ่งกีดขวาง/เหรียญ
      if(boss?.type==='test1'){ for(const f of fires){ drawFire(f); } }
      if(boss?.type==='test2'){ for(const b of bossBlocks){ drawBossBlock(b); } }
      if(boss?.type==='test3'){ for(const b of beams){ drawBeam(b); } for(const s of shards){ drawShard(s); } }
      for(const c of coins){ drawCoin(c); }

      // หลอดเลือดสีเขียว "บนตัวบอส"
      if(boss){ drawBossHealthBar(boss); }
    }

    // hamster
    if(hamster){ drawHamster(hamster); }

    // UI scores
    ctx.fillStyle='rgba(0,0,0,.6)'; ctx.font='bold 22px ui-sans-serif, system-ui'; 
    ctx.fillText('คะแนน: '+score,14,30);
    ctx.fillStyle='rgba(0,0,0,.35)'; ctx.font='14px ui-sans-serif, system-ui'; ctx.fillText('สถิติสูงสุด: '+best,14,52);

    if(scoreMul>1){
      ctx.fillStyle='rgba(34,197,94,.12)'; ctx.fillRect(WIDTH-120,10,110,26);
      ctx.strokeStyle='rgba(16,185,129,.35)'; ctx.strokeRect(WIDTH-120+.5,10+.5,109,25);
      ctx.fillStyle='#065f46'; ctx.font='bold 13px ui-sans-serif, system-ui';
      ctx.textAlign='center'; ctx.fillText('x'+scoreMul+'  '+Math.ceil(scoreMulTimer)+'s', WIDTH-65, 28);
      ctx.textAlign='start';
    }

    // ท็อปโน้ตเล็ก ๆ
    if(notiTimer>0){
      ctx.fillStyle='rgba(255,255,255,.9)'; ctx.fillRect(60, HEIGHT*0.14, WIDTH-120, 42);
      ctx.strokeStyle='rgba(0,0,0,.06)'; ctx.strokeRect(60.5, HEIGHT*0.14+0.5, WIDTH-121, 41);
      ctx.fillStyle='#0f172a'; ctx.font='14px ui-sans-serif, system-ui'; ctx.textAlign='center'; ctx.fillText(notiText, WIDTH/2, HEIGHT*0.14+26); ctx.textAlign='start';
    }

    // power message (แฮมสเตอร์)
    if(powerTextTimer>0){
      const a = Math.min(1, powerTextTimer / POWER_TEXT_LIFETIME);
      ctx.save();
      ctx.globalAlpha = 0.15 + 0.85*a;
      ctx.fillStyle='#fff';
      const bw = WIDTH-60, bh=80, bx=30, by=HEIGHT*0.35+20;
      ctx.fillRect(bx,by,bw,bh);
      ctx.strokeStyle='rgba(0,0,0,.08)'; ctx.strokeRect(bx+.5,by+.5,bw-1,bh-1);
      ctx.fillStyle='#111827'; ctx.font='bold 18px ui-sans-serif, system-ui'; ctx.textAlign='center';
      ctx.fillText('ได้เวลาเก็บเกี่ยวทานตะวันแล้ววววว!', WIDTH/2, by+48);
      ctx.restore();
    }

    if(!playing){ overlay('พิมพ์ชื่อ แล้วกด "เริ่มใหม่" หรือ Space เพื่อเริ่ม', 0.75); }
    else if(gameOver){ overlay('จบเกม! เลือกตัวเลือกด้านล่าง', 0.75); drawScoreboard(); drawGameOverButtons(); }
  }

  // ===== วาดของบอส (ท่อ/ลำแสง/หลอดเลือด) =====
  function drawBossHealthBar(b){
    const need = b.coinsToWin||1, got=b.hits||0;
    const ratio = clamp(1 - got/need, 0, 1); // เลือดที่เหลือ
    const bw = 50, bh = 6;
    const x = b.x - bw/2, y = b.y - 38; // "บนตัวบอส" (เหนือกลางตัวเล็กน้อย)
    ctx.save();
    // เงาบาง ๆ
    ctx.fillStyle='rgba(0,0,0,.25)'; ctx.fillRect(x, y, bw, bh);
    // เลือดสีเขียว
    ctx.fillStyle='#22c55e'; ctx.fillRect(x, y, bw*ratio, bh);
    // เส้นขอบ
    ctx.strokeStyle='rgba(0,0,0,.35)'; ctx.strokeRect(x+.5,y+.5,bw-1,bh-1);
    ctx.restore();
  }

  // ===== ของเดิมอื่น ๆ =====
  function drawCoin(c){ const r=c.r; ctx.save(); ctx.translate(c.x,c.y); ctx.rotate(Math.sin(c.spin)*0.3); ctx.fillStyle='#f59e0b'; ctx.beginPath(); ctx.arc(0,0,r+2,0,Math.PI*2); ctx.fill(); ctx.fillStyle='var(--coin)'; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#fef3c7'; starPath(ctx,5,r*0.5,r*0.2); ctx.fill(); ctx.restore(); }
  function drawFire(f){ ctx.save(); ctx.translate(f.x,f.y); ctx.fillStyle='var(--fire)'; ctx.beginPath(); ctx.moveTo(0,0); ctx.bezierCurveTo(-8,-6,-14,6,0,12); ctx.bezierCurveTo(14,6,8,-6,0,0); ctx.fill(); ctx.fillStyle='#fdba74'; ctx.beginPath(); ctx.arc(-2,4,3,0,Math.PI*2); ctx.fill(); ctx.restore(); }
  function drawPipe(p,topOff,botOff){ const pipeW=60, r=10, topH=p.topH, bottomY=p.topH+PIPE_GAP; ctx.fillStyle='#a3e635'; roundRect(ctx,p.x,0+topOff,pipeW,topH,r); ctx.fill(); roundRect(ctx,p.x,bottomY+botOff,pipeW,HEIGHT-bottomY-30,r); ctx.fill(); }
  function drawBossBlock(b){
    const pipeW=b.w||60, r=10, topH=b.topH, bottomY=b.topH+(b.gap||BOSS_BLOCK_GAP);
    ctx.fillStyle='var(--block)';
    roundRect(ctx, b.x, 0, pipeW, topH, r); ctx.fill();
    roundRect(ctx, b.x, bottomY, pipeW, HEIGHT-bottomY-30, r); ctx.fill();
  }
  function drawBeam(b){ ctx.save(); ctx.fillStyle='var(--beam)'; ctx.fillRect(b.x-b.len, b.y-b.h/2, b.len, b.h); ctx.restore(); }
  function drawShard(s){ ctx.save(); ctx.fillStyle='var(--shard)'; ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fill(); ctx.restore(); }
  function drawHamster(h){
    ctx.save(); ctx.translate(h.x, h.y);
    ctx.fillStyle='var(--ham-ear)'; ctx.beginPath(); ctx.arc(6,4,6,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc( h.w-6,4,6,0,Math.PI*2); ctx.fill();
    roundRect(ctx,0,0,h.w,h.h,10); ctx.fillStyle='var(--ham)'; ctx.fill();
    ctx.fillStyle='var(--ham-belly)'; ctx.beginPath(); ctx.ellipse(h.w/2,h.h/1.7, h.w*0.28, h.h*0.3, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(h.w*0.35,h.h*0.4,2.2,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(h.w*0.65,h.h*0.4,2.2,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#fff'; ctx.fillRect(h.w*0.48,h.h*0.6,4,5);
    ctx.restore();
  }
  function starPath(ctx,spikes,outerR,innerR){ let rot=Math.PI/2*3, x=0, y=0, step=Math.PI/spikes; ctx.beginPath(); ctx.moveTo(0,-outerR); for(let i=0;i<spikes;i++){ x=Math.cos(rot)*outerR; y=Math.sin(rot)*outerR; ctx.lineTo(x,y); rot+=step; x=Math.cos(rot)*innerR; y=Math.sin(rot)*innerR; ctx.lineTo(x,y); rot+=step; } ctx.lineTo(0,-outerR); ctx.closePath(); }
  function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

  function drawGameOverButtons(){
    const btnW=220, btnH=36, gap=14; const x=(WIDTH-btnW)/2; const yBase=HEIGHT*0.35+100;
    ctx.fillStyle='#2563eb'; ctx.fillRect(x, yBase, btnW, btnH);
    ctx.fillStyle='#fff'; ctx.font='14px ui-sans-serif, system-ui'; ctx.textAlign='center'; ctx.fillText('ส่งสกอร์ออนไลน์ (GitHub)', WIDTH/2, yBase+23);
    const y2=yBase + btnH + gap;
    ctx.fillStyle='#22c55e'; ctx.fillRect(x, y2, btnW, btnH);
    ctx.fillStyle='#fff'; ctx.fillText('เริ่มใหม่', WIDTH/2, y2+23);
    gameOverButtons.send={x, y:yBase, w:btnW, h:btnH};
    gameOverButtons.restart={x, y:y2, w:btnW, h:btnH};
  }

  function drawScoreboard(){
    ensureOnlineScores();
    const arr = onlineScores || [];
    const padX=24, padY=HEIGHT*0.35+160, w=WIDTH-48, h=HEIGHT-padY-20;
    ctx.fillStyle='rgba(255,255,255,.95)'; ctx.fillRect(padX,padY,w,h);
    ctx.strokeStyle='rgba(0,0,0,.08)'; ctx.strokeRect(padX+.5,padY+.5,w-1,h-1);
    ctx.fillStyle='#0f172a'; ctx.font='bold 16px ui-sans-serif, system-ui';
    ctx.fillText('สกอร์บอร์ด (จาก GitHub Issues)', padX+14, padY+28);
    ctx.font='12px ui-sans-serif, system-ui'; ctx.fillStyle='#64748b';
    if(!onlineScores){ ctx.fillText('กำลังโหลดจาก GitHub…', padX+14, padY+48); return; }
    renderRows(arr.slice(0,10), padX+14, padY+54);
  }
  function renderRows(arr, x, y){
    ctx.save(); ctx.font='13px ui-sans-serif, system-ui';
    for(let i=0;i<arr.length;i++){
      const s=arr[i]; const yy=y+i*18;
      ctx.fillStyle='#0f172a'; ctx.fillText(`${i+1}. ${s.name}`, x, yy);
      ctx.textAlign='right'; ctx.fillText(String(s.score), x+300, yy);
      ctx.textAlign='start'; ctx.fillStyle='#64748b'; ctx.fillText('x'+(s.speed||1), x+320, yy);
    }
    ctx.restore();
  }

  // เริ่มด้วยสถานะ "รอเริ่ม"
  playing=false; draw();
  function overlay(text,alpha=0.7){
    ctx.fillStyle=`rgba(255,255,255,${alpha})`;
    ctx.fillRect(18, HEIGHT*0.35, WIDTH-36, 120);
    ctx.strokeStyle='rgba(0,0,0,.08)'; ctx.strokeRect(18.5, HEIGHT*0.35+0.5, WIDTH-37, 119);
    ctx.fillStyle='#0f172a'; ctx.font='16px ui-sans-serif, system-ui';
    ctx.textAlign='center'; ctx.fillText(text, WIDTH/2, HEIGHT*0.35+66); ctx.textAlign='start';
  }

  // ===== SELF TESTS (console) =====
  (function runSelfTests(){
    const tests=[]; function assert(name, cond){ tests.push({name, pass: !!cond}); if(!cond) console.error('❌', name); }

    // parser
    const sampleBody = `<!-- FLAPPY_SCORE_V1 -->\n\`\`\`json\n{"name":"TestUser","score":12,"speed":2,"ts":1733960000000}\n\`\`\``;
    const parsed = parseScoreFromIssueBody(sampleBody);
    assert('parser returns object', parsed && typeof parsed==='object');
    assert('parsed.score === 12', parsed && parsed.score===12);

    // ไม่มีประกาศซ้ำตัวแปรหลัก
    assert('notiText is string', typeof notiText === 'string');
    assert('gameOverButtons ok', gameOverButtons && 'send' in gameOverButtons && 'restart' in gameOverButtons);

    // โอกาสเกิดแฮมสเตอร์ ~20% (ทดสอบเชิงสถิติหยาบ)
    let count=0,N=1000; for(let i=0;i<N;i++){ if(Math.random()<HAMSTER_CHANCE) count++; }
    const p=count/N; assert('hamster chance ~0.2', p>0.15 && p<0.25);

    // บอสสุ่มต้องเป็นหนึ่งในชุด test1/2/3
    const types = new Set(['test1','test2','test3']);
    let ok=true; for(let i=0;i<20;i++){ const t=['test1','test2','test3'][Math.floor(Math.random()*3)]; if(!types.has(t)) ok=false; }
    assert('boss type in allowed set', ok);

    // สัดส่วนเลือดคำนวณถูก (1 - hits/need)
    const mock={coinsToWin:10,hits:3}; const ratio=clamp(1-mock.hits/mock.coinsToWin,0,1);
    assert('hp ratio 0..1', ratio>0 && ratio<1 && Math.abs(ratio-0.7)<1e-9);

    const passed=tests.filter(t=>t.pass).length;
    console.log(`✅ Self-tests passed ${passed}/${tests.length}`);
  })();
  </script>
</body>
</html>
